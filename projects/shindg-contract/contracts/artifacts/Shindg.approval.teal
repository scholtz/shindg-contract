#pragma version 10

// This TEAL was generated by TEALScript v0.94.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(string,string)void
*abi_route_createApplication:
	// symbol: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createApplication(string,string)void
	callsub createApplication
	int 1
	return

// createApplication(name: string, symbol: string): void
//
// Constructor
// @param name NFT Name
// @param symbol NFT Symbol
createApplication:
	proto 2 0

	// contracts\Shindg.algo.ts:86
	// this.name.value = name
	byte 0x6e616d65 // "name"
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts\Shindg.algo.ts:87
	// this.symbol.value = symbol
	byte 0x73796d626f6c // "symbol"
	frame_dig -2 // symbol: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put
	retsub

// transferTo(to: Address, tokenId: uint256): void
//
// Execute transfer - change the state of the token.
// @param to Address of receiver
// @param tokenId TokenID
transferTo:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Shindg.algo.ts:98
	// tokenId64 = tokenId as uint64
	frame_dig -2 // tokenId: uint256
	dup
	bitlen
	int 64
	<=

	// tokenId as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	frame_bury 0 // tokenId64: uint64

	// contracts\Shindg.algo.ts:99
	// assert(this.tokenBox(tokenId64).exists)
	frame_dig 0 // tokenId64: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts\Shindg.algo.ts:100
	// box = this.tokenBox(tokenId64).value
	frame_dig 0 // tokenId64: uint64
	itob
	frame_bury 1 // storage key//box

	// contracts\Shindg.algo.ts:101
	// box.owner = to
	frame_dig 1 // storage key//box
	box_get

	// box value does not exist: this.tokenBox(tokenId64).value
	assert
	store 255 // full array
	load 255 // full array
	int 8
	frame_dig -1 // to: Address
	replace3
	frame_dig 1 // storage key//box
	dup
	box_del
	pop
	swap
	box_put

	// contracts\Shindg.algo.ts:102
	// box.controller = to
	frame_dig 1 // storage key//box
	box_get

	// box value does not exist: this.tokenBox(tokenId64).value
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -1 // to: Address
	replace3
	frame_dig 1 // storage key//box
	dup
	box_del
	pop
	swap
	box_put
	retsub

// arc72_transferFrom(address,address,uint256)void
*abi_route_arc72_transferFrom:
	// tokenId: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (tokenId) for arc72_transferFrom must be a uint256
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (to) for arc72_transferFrom must be a address
	assert

	// _from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (_from) for arc72_transferFrom must be a address
	assert

	// execute arc72_transferFrom(address,address,uint256)void
	callsub arc72_transferFrom
	int 1
	return

// arc72_transferFrom(_from: Address, to: Address, tokenId: uint256): void
//
// Transfers ownership of an NFT
arc72_transferFrom:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Shindg.algo.ts:111
	// token = this.tokenBox(tokenId as uint64).value
	frame_dig -3 // tokenId: uint256
	dup
	bitlen
	int 64
	<=

	// tokenId as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	frame_bury 0 // storage key//token

	// contracts\Shindg.algo.ts:113
	// key: Control = { owner: this.txn.sender, controller: _from }
	txn Sender
	frame_dig -1 // _from: Address
	concat
	frame_bury 1 // key: Control

	// *if0_condition
	// contracts\Shindg.algo.ts:115
	// this.txn.sender === _from || this.txn.sender === token.controller || this.controlBox(key).exists
	txn Sender
	frame_dig -1 // _from: Address
	==
	dup
	bnz *skip_or0
	txn Sender
	frame_dig 0 // storage key//token
	box_get

	// box value does not exist: this.tokenBox(tokenId as uint64).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 32
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig 1 // key: Control
	box_len
	swap
	pop
	||

*skip_or1:
	bz *if0_else

	// *if0_consequent
	// contracts\Shindg.algo.ts:116
	// this.transferTo(to, tokenId)
	frame_dig -3 // tokenId: uint256
	frame_dig -2 // to: Address
	callsub transferTo
	b *if0_end

*if0_else:
	// Transfer not authorized
	err

*if0_end:
	retsub

// arc72_approve(address,uint256)void
*abi_route_arc72_approve:
	// tokenId: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (tokenId) for arc72_approve must be a uint256
	assert

	// approved: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (approved) for arc72_approve must be a address
	assert

	// execute arc72_approve(address,uint256)void
	callsub arc72_approve
	int 1
	return

// arc72_approve(approved: Address, tokenId: uint256): void
//
//
// Approve a controller for a single NFT
//
// @param approved Approved controller address
// @param tokenId The ID of the NFT
arc72_approve:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Shindg.algo.ts:128
	// tokenId64 = tokenId as uint64
	frame_dig -2 // tokenId: uint256
	dup
	bitlen
	int 64
	<=

	// tokenId as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	frame_bury 0 // tokenId64: uint64

	// contracts\Shindg.algo.ts:129
	// assert(this.tokenBox(tokenId64).exists)
	frame_dig 0 // tokenId64: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts\Shindg.algo.ts:130
	// box = this.tokenBox(tokenId64).value
	frame_dig 0 // tokenId64: uint64
	itob
	frame_bury 1 // storage key//box

	// contracts\Shindg.algo.ts:131
	// assert(this.txn.sender === box.owner)
	txn Sender
	frame_dig 1 // storage key//box
	box_get

	// box value does not exist: this.tokenBox(tokenId64).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	==
	assert

	// contracts\Shindg.algo.ts:133
	// box.controller = approved
	frame_dig 1 // storage key//box
	box_get

	// box value does not exist: this.tokenBox(tokenId64).value
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -1 // approved: Address
	replace3
	frame_dig 1 // storage key//box
	dup
	box_del
	pop
	swap
	box_put
	retsub

// arc72_setApprovalForAll(address,bool)void
*abi_route_arc72_setApprovalForAll:
	// approved: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==

	// argument 0 (approved) for arc72_setApprovalForAll must be a bool
	assert
	int 0
	getbit

	// operator: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (operator) for arc72_setApprovalForAll must be a address
	assert

	// execute arc72_setApprovalForAll(address,bool)void
	callsub arc72_setApprovalForAll
	int 1
	return

// arc72_setApprovalForAll(operator: Address, approved: boolean): void
//
//
// Approve an operator for all NFTs for a user
//
// @param operator Approved operator address
// @param approved true to give approval, false to revoke
// @returns
arc72_setApprovalForAll:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Shindg.algo.ts:145
	// key: Control = { owner: this.txn.sender, controller: operator }
	txn Sender
	frame_dig -1 // operator: Address
	concat
	frame_bury 0 // key: Control

	// *if1_condition
	// contracts\Shindg.algo.ts:147
	// approved
	frame_dig -2 // approved: boolean
	bz *if1_elseif1_condition

	// *if1_consequent
	// contracts\Shindg.algo.ts:147
	// this.controlBox(key).value = ''
	frame_dig 0 // key: Control
	dup
	box_del
	pop
	byte 0x // ""
	box_put
	b *if1_end

*if1_elseif1_condition:
	// contracts\Shindg.algo.ts:148
	// this.controlBox(key).exists
	frame_dig 0 // key: Control
	box_len
	swap
	pop
	bz *if1_end

	// *if1_elseif1_consequent
	// contracts\Shindg.algo.ts:148
	// this.controlBox(key).delete()
	frame_dig 0 // key: Control
	box_del

*if1_end:
	retsub

// arc72_ownerOf(uint256)address
*abi_route_arc72_ownerOf:
	// The ABI return prefix
	byte 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (tokenId) for arc72_ownerOf must be a uint256
	assert

	// execute arc72_ownerOf(uint256)address
	callsub arc72_ownerOf
	concat
	log
	int 1
	return

// arc72_ownerOf(tokenId: uint256): Address
//
//
// Returns the address of the current owner of the NFT with the given tokenId
//
// @param tokenId The ID of the NFT
// @returns The current owner of the NFT
arc72_ownerOf:
	proto 1 1

	// contracts\Shindg.algo.ts:162
	// return this.tokenBox(tokenId as uint64).value.owner;
	frame_dig -1 // tokenId: uint256
	dup
	bitlen
	int 64
	<=

	// tokenId as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	box_get

	// box value does not exist: this.tokenBox(tokenId as uint64).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	retsub

// arc72_tokenURI(uint256)string
*abi_route_arc72_tokenURI:
	// The ABI return prefix
	byte 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (tokenId) for arc72_tokenURI must be a uint256
	assert

	// execute arc72_tokenURI(uint256)string
	callsub arc72_tokenURI
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc72_tokenURI(tokenId: uint256): string
//
//
// Returns a URI pointing to the NFT metadata
//
// @param tokenId The ID of the NFT
// @returns URI to token metadata
arc72_tokenURI:
	proto 1 1

	// contracts\Shindg.algo.ts:174
	// return this.tokenBox(tokenId as uint64).value.uri;
	frame_dig -1 // tokenId: uint256
	dup
	bitlen
	int 64
	<=

	// tokenId as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	box_get

	// box value does not exist: this.tokenBox(tokenId as uint64).value
	assert
	store 255 // full array
	int 76
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	retsub

// arc72_totalSupply()uint256
*abi_route_arc72_totalSupply:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc72_totalSupply()uint256
	callsub arc72_totalSupply
	dup
	bitlen
	int 256
	<=

	// arc72_totalSupply return value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc72_totalSupply(): uint256
//
// Returns the number of NFTs currently defined by this contract
arc72_totalSupply:
	proto 0 1

	// contracts\Shindg.algo.ts:182
	// return this.index.value as uint256;
	byte 0x696e646578 // "index"
	app_global_get
	itob
	retsub

// arc72_tokenByIndex(uint256)uint256
*abi_route_arc72_tokenByIndex:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (index) for arc72_tokenByIndex must be a uint256
	assert

	// execute arc72_tokenByIndex(uint256)uint256
	callsub arc72_tokenByIndex
	dup
	bitlen
	int 256
	<=

	// arc72_tokenByIndex return value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc72_tokenByIndex(index: uint256): uint256
//
// Returns the token ID of the token with the given index among all NFTs defined by the contract
arc72_tokenByIndex:
	proto 1 1

	// contracts\Shindg.algo.ts:190
	// return index;
	frame_dig -1 // index: uint256
	retsub

// mint(uint64,address,string,string,string,string,uint64,uint64)void
*abi_route_mint:
	// currency: uint64
	txna ApplicationArgs 8
	btoi

	// price: uint64
	txna ApplicationArgs 7
	btoi

	// uri: string
	txna ApplicationArgs 6
	extract 2 0

	// image: string
	txna ApplicationArgs 5
	extract 2 0

	// seat: string
	txna ApplicationArgs 4
	extract 2 0

	// area: string
	txna ApplicationArgs 3
	extract 2 0

	// to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 6 (to) for mint must be a address
	assert

	// state: uint64
	txna ApplicationArgs 1
	btoi

	// execute mint(uint64,address,string,string,string,string,uint64,uint64)void
	callsub mint
	int 1
	return

// mint(state: uint64, to: Address, area: string, seat: string, image: string, uri: string, price: uint64, currency: uint64): void
mint:
	proto 8 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Shindg.algo.ts:204
	// assert(
	//       this.txn.sender === globals.creatorAddress,
	//       'Only creator is allowed to mint specific NFTs for this collection'
	//     )
	txn Sender
	global CreatorAddress
	==

	// Only creator is allowed to mint specific NFTs for this collection
	assert

	// contracts\Shindg.algo.ts:208
	// assert(state === 1 || state === 10, 'Minter can set state only to ON_SALE or not for sale ')
	frame_dig -1 // state: uint64
	int 1
	==
	dup
	bnz *skip_or2
	frame_dig -1 // state: uint64
	int 10
	==
	||

*skip_or2:
	// Minter can set state only to ON_SALE or not for sale
	assert

	// contracts\Shindg.algo.ts:209
	// index = this.index.value
	byte 0x696e646578 // "index"
	app_global_get
	frame_bury 0 // index: uint64

	// contracts\Shindg.algo.ts:211
	// token: Token = {
	//       state: state,
	//       owner: to,
	//       controller: to,
	//       area: area,
	//       seat: seat,
	//       uri: uri,
	//       image: image,
	//       price: price,
	//       currency: currency,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0060 // initial head offset
	frame_dig -1 // state: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // to: Address
	callsub *process_static_tuple_element
	frame_dig -2 // to: Address
	callsub *process_static_tuple_element
	frame_dig -3 // area: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -4 // seat: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -6 // uri: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // image: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -7 // price: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -8 // currency: uint64
	itob
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // token: Token

	// contracts\Shindg.algo.ts:222
	// assert(token.state !== 0, 'Token state is not 0')
	frame_dig 1 // token: Token
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 0
	!=

	// Token state is not 0
	assert

	// contracts\Shindg.algo.ts:223
	// this.tokenBox(index).value = token
	frame_dig 0 // index: uint64
	itob
	dup
	box_del
	pop
	frame_dig 1 // token: Token
	box_put

	// contracts\Shindg.algo.ts:224
	// this.transferTo(to, index as uint256)
	frame_dig 0 // index: uint64
	itob
	dup
	bitlen
	int 256
	<=

	// index as uint256 overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig -2 // to: Address
	callsub transferTo

	// contracts\Shindg.algo.ts:227
	// this.index.value = index + 1
	byte 0x696e646578 // "index"
	frame_dig 0 // index: uint64
	int 1
	+
	app_global_put
	retsub

// checkIn(uint64,uint64)void
*abi_route_checkIn:
	// state: uint64
	txna ApplicationArgs 2
	btoi

	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute checkIn(uint64,uint64)void
	callsub checkIn
	int 1
	return

// checkIn(nftIndex: uint64, state: uint64): void
//
// Owner of NFT can check in or check out from the event
// @param nftIndex
// @param state
checkIn:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Shindg.algo.ts:236
	// nft = this.tokenBox(nftIndex).value
	frame_dig -1 // nftIndex: uint64
	itob
	frame_bury 0 // storage key//nft

	// contracts\Shindg.algo.ts:237
	// assert(nft.owner === this.txn.sender, 'Only owner of the NFT can change the state')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	txn Sender
	==

	// Only owner of the NFT can change the state
	assert

	// contracts\Shindg.algo.ts:238
	// assert(state === 100 || state === 1000, 'Only owner of the NFT can change the state')
	frame_dig -2 // state: uint64
	int 100
	==
	dup
	bnz *skip_or3
	frame_dig -2 // state: uint64
	int 1000
	==
	||

*skip_or3:
	// Only owner of the NFT can change the state
	assert

	// contracts\Shindg.algo.ts:239
	// nft.state = state
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -2 // state: uint64
	itob
	replace3
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put
	retsub

// buy(txn,uint64)void
*abi_route_buy:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// buyTxn: txn
	txn GroupIndex
	int 1
	-

	// execute buy(txn,uint64)void
	callsub buy
	int 1
	return

// buy(buyTxn: Txn, nftIndex: uint64): void
//
// Owner of NFT can check in or check out from the event
// @param buyTxn The buy transaction
// @param nftIndex NFT Index
buy:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Shindg.algo.ts:248
	// nft = this.tokenBox(nftIndex).value
	frame_dig -2 // nftIndex: uint64
	itob
	frame_bury 0 // storage key//nft

	// contracts\Shindg.algo.ts:249
	// assert(nft.state === 1, 'NFT Ticket is not for sale')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 1
	==

	// NFT Ticket is not for sale
	assert

	// contracts\Shindg.algo.ts:250
	// assert(nft.owner === buyTxn.assetReceiver, 'Price must be paid to the owner of the NFT')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	frame_dig -1 // buyTxn: Txn
	gtxns AssetReceiver
	==

	// Price must be paid to the owner of the NFT
	assert

	// contracts\Shindg.algo.ts:251
	// assert(nft.price === buyTxn.assetAmount, 'Exact price must be paid to the owner of the NFT')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 80 8
	btoi
	frame_dig -1 // buyTxn: Txn
	gtxns AssetAmount
	==

	// Exact price must be paid to the owner of the NFT
	assert

	// contracts\Shindg.algo.ts:253
	// nft.owner = buyTxn.sender
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	int 8
	frame_dig -1 // buyTxn: Txn
	gtxns Sender
	replace3
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put

	// contracts\Shindg.algo.ts:254
	// nft.state = 10
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	byte 0x000000000000000a
	replace2 0
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put
	retsub

// setPrice(uint64,uint64,uint64)void
*abi_route_setPrice:
	// currency: uint64
	txna ApplicationArgs 3
	btoi

	// price: uint64
	txna ApplicationArgs 2
	btoi

	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPrice(uint64,uint64,uint64)void
	callsub setPrice
	int 1
	return

// setPrice(nftIndex: uint64, price: uint64, currency: uint64): void
//
// Owner of NFT can check in or check out from the event
// @param nftIndex NFT Index
// @param price The price which has to be paid
// @param currency The currency for price
setPrice:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Shindg.algo.ts:264
	// nft = this.tokenBox(nftIndex).value
	frame_dig -1 // nftIndex: uint64
	itob
	frame_bury 0 // storage key//nft

	// contracts\Shindg.algo.ts:265
	// assert(nft.state === 1 || nft.state === 10, 'NFT Ticket is not in valid state')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 1
	==
	dup
	bnz *skip_or4
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 10
	==
	||

*skip_or4:
	// NFT Ticket is not in valid state
	assert

	// contracts\Shindg.algo.ts:266
	// assert(nft.owner === this.txn.sender, 'Only owner of this NFT can change the price')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	txn Sender
	==

	// Only owner of this NFT can change the price
	assert

	// contracts\Shindg.algo.ts:268
	// nft.state = 1
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	byte 0x0000000000000001
	replace2 0
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put

	// contracts\Shindg.algo.ts:269
	// nft.currency = currency
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	int 88
	frame_dig -3 // currency: uint64
	itob
	replace3
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put

	// contracts\Shindg.algo.ts:270
	// nft.price = price
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	int 80
	frame_dig -2 // price: uint64
	itob
	replace3
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put
	retsub

// setNotForSale(uint64)void
*abi_route_setNotForSale:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute setNotForSale(uint64)void
	callsub setNotForSale
	int 1
	return

// setNotForSale(nftIndex: uint64): void
//
// Set not for sale
// @param nftIndex NFT
setNotForSale:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Shindg.algo.ts:278
	// nft = this.tokenBox(nftIndex).value
	frame_dig -1 // nftIndex: uint64
	itob
	frame_bury 0 // storage key//nft

	// contracts\Shindg.algo.ts:279
	// assert(nft.state === 1, 'NFT Ticket is not for sale')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 1
	==

	// NFT Ticket is not for sale
	assert

	// contracts\Shindg.algo.ts:280
	// assert(nft.owner === this.txn.sender, 'Only owner of this NFT can change it from being on sale')
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	txn Sender
	==

	// Only owner of this NFT can change it from being on sale
	assert

	// contracts\Shindg.algo.ts:282
	// nft.state = 10
	frame_dig 0 // storage key//nft
	box_get

	// box value does not exist: this.tokenBox(nftIndex).value
	assert
	store 255 // full array
	load 255 // full array
	byte 0x000000000000000a
	replace2 0
	frame_dig 0 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put
	retsub

*create_NoOp:
	method "createApplication(string,string)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "arc72_transferFrom(address,address,uint256)void"
	method "arc72_approve(address,uint256)void"
	method "arc72_setApprovalForAll(address,bool)void"
	method "arc72_ownerOf(uint256)address"
	method "arc72_tokenURI(uint256)string"
	method "arc72_totalSupply()uint256"
	method "arc72_tokenByIndex(uint256)uint256"
	method "mint(uint64,address,string,string,string,string,uint64,uint64)void"
	method "checkIn(uint64,uint64)void"
	method "buy(txn,uint64)void"
	method "setPrice(uint64,uint64,uint64)void"
	method "setNotForSale(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_arc72_transferFrom *abi_route_arc72_approve *abi_route_arc72_setApprovalForAll *abi_route_arc72_ownerOf *abi_route_arc72_tokenURI *abi_route_arc72_totalSupply *abi_route_arc72_tokenByIndex *abi_route_mint *abi_route_checkIn *abi_route_buy *abi_route_setPrice *abi_route_setNotForSale

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub